<script>

console.log( 123 ^ 0 ); // 123 - исключающее ИЛИ : у нуля все биты = 0 -> если у взаимодействующего числа бит = 1, то в результат в данную позицию попадает 1
console.log( 0 ^ 123 ); // 123 - то же, что и в 1-ом случае. потому в обоих сохраняется число, взаимодействующее с "0"
console.log( ~~123   ); // 123 - двойное побитовое отрицание. дважды переключившись, биты возвращаются в начальное состояние. т.к. нет дробной части - ничего не теряется

// - - - - - | - - - - -

function isInteger(val)
{
    return val === (val ^ 0);
}

console.log( isInteger(1)    ); // true
console.log( isInteger(1.5)  ); // false
console.log( isInteger(-0.5) ); // false

// - - - - - | - - - - -

let a = 13, b = 18;
console.log ( (a ^ b) == (b ^ a) ); // симметрично; поскольку результат,
console.log ( (a & b) == (b & a) ); // симметрично; это слияние бит,
console.log ( (a | b) == (b | a) ); // симметрично; а не воздействие одного значения на другое

// - - - - - | - - - - -

console.log( 123456789      ^ 0 ); // 123456789
console.log( 12345678912345 ^ 0 ); // 1942903641 - нарушение происходит при отбрасывании дробной части и переводе числа в 32-битное во время побитовой операции

</script>
